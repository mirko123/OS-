Разписани упражнения по Операционни системи за специалност Информатика от Йордан Бабуков.

Операционни системи, упражнение 9

Cистемни примитиви на C за работа с файлове

1)
int open(const char *pathname, int flag[| more flags] );
първият аргумент е име на файл, който искаме да поставим в режим flag.

flags:
О_RDONLY	-> отваря файл pathname в режим на четене
O_WRONLY	-> отваря файл pathname в режим на писане
O_RDWR		-> отваря файл pathname в режим на писане и четене
O_TRUNC		-> отваря файл pathname, като му занулява съдържанието
O_APPEND	-> отваря файл pathname, като поставя указател към края на съдържанието на файла.
O_CREAT		-> създава нов файл с име pathname, ако не съществува.

2)
int close(int fd); 
затваря новозаделения файлов дескриптор от open() към файла.

3)
ssize_t read(int fd, void *buf, size_t count);
Първият аргумент е файлов дескриптор към файл, който трябва да е отворен за четене
След което прочитаме count (третият аргумент) на брой символа, 
които се запаметяват временно в buf (вторият аргумент)

4)
ssize_t write(int fd, const void *buf, size_t count);
Първият аргумент е файлов дескриптор към файл, който трябва да е отворен за писане
След което подаваме count (третият аргумент) на брой символа за запис
Които са предварително запазени в buf (вторият аргумент)

*Най-често размера на буферите за четене и писане са с еднакъв размер,
като оптимално бихме искали да е n*големината на един блок в системата.
Разбира се в по-новите имплементации за писане, поддържат буфериране, събирайки
данните и записвайки ги на устройството в последствие.

Пример и обяснения - директно върху задачи:
Задача 1:

Копирайте съдържанието на файл1 във файл2
]$ vi task1.c
//копирайте съдържанието на файл1 във файл2
#include <fcntl.h>      //библиотека необходима за изпълнение на open
#include <stdlib.h>     //библиотека необходима за изпълнение на exit()

//argc е брой подадени входни параметри (в случая нула)
//argv се асоциира със стойностите на подадените входни параметри
//пример за достъп до 1-вия подаден входен параметър: argv[1] и тн
//пример за обхождане на всички подадени входни параметри: argv[*]
main(int argc, char* argv[]){
        int fd1;        //ще го асоциирам с първия файл от който ще чета
        int fd2;        //ще го асициирам с втория файл, в който ще пиша
        char c;         //това ще ми е текущо прочетения символ от първия файл и който ще запиша във втория файл.

        //системните примитив на C връщат код -1 при грешка и > от -1 при успех
        //Изключително желателно е да се прави проверка дали файлът е отворен успешно
        //open връща цялочислена стойност, която служи за файлов дескриптор към файла
        //след успешно изпълнение на open, ще работим с файловия дескриптор, а не с името на файла!
        if ( ( fd1 = open("/home/jbabukov/file_to_read", O_RDONLY) ) == -1 ){
                /двойката в долния ред се асоциира със стандартния изход за грешки, ако беше 1, щеше да се асоциира със стандартния изход
                write(2, "File faild to open in read mode\n", 33);
                exit(-1);
        }

        if ( ( fd2 = open("/home/jbabukov/file_to_write", O_CREAT|O_WRONLY) ) == -1 ){
                write(2, "File failed to open in write mode\n", 33);
                exit(-1);
        }

        //прочитане символ по символ първия файл и като прочетем символ го записваме във втория.
        while ( read(fd1, &c, 1) ){
                write(fd2, &c, 1);
        }

        //затваряме заделените файлови дескриптори
        close(fd1);
        close(fd2);
}

Остава да си компилираме творението:

cc task1.c -o task1
сега го стартираме и се наслаждаваме на резултатите:
./task1

Задача 2:
Реализирайте команда head без опции (т.е. винаги да извежда на стандартния изход само първите 10 реда от съдържанието на файл подаден като първи параматър)

cat task2.c
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

main(int argc, char* argv[]){
        int fd1;
        int i=0;        //броят на символи за нов редове
        char c;

        if ( ( fd1 = open(argv[1], O_RDONLY) ) == -1 ){
                write(2, "File failed to open in read mode\n", 33);
                exit(-1);
        }

        while ( read(fd1, &c, 1) ){
                if( c == '\n' ){
                        i=i+1;
                }

                //извеждам на стандартния изход прочетения символ
                write(1, &c, 1);

                //при достигане на 10ти символ за нов ред, приключвам изпълнението на програмата.
                if( i == 10 ){
                        close(fd1);
                        exit(0);
                }
        }
        close(fd1);
}

Koмпилираме:
cc task2.c -o task2

и стартираме:
./task2 task1.c

Задача 3:
Реализирайте команда wc

Опитайте сами, ще я решим за разгрявка в четвъртък.
