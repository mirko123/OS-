Разписани упражнения по Операционни системи за специалност Информатика от Йордан Бабуков.

Операционни системи, упражнение 03

Команди до момента:
упр1) pwd, ls, echo, date, man, cd
упр2) who, passwd, cat, more, less, head, tail, touch, rm, mkdir, rmdir, cp, mv, sort, cut, grep

Новo:
Команди wc, sleep, read. Код на изход на команда.
Фонов режим на команди.
Работа с променливи.
Wildcards към команда "ls"
Пренасочване на стандартен вход, стандартен изход, изход за грешка.
Регулярни изрази към команда "grep"
Конвейр от команди.

0)
wc	-> извежда информация за броя редове, броя думи и броя символи във файл.
wc -l /etc/passwd	-> извежда броят редове във файл /etc/passwd
wc -w /etc/passwd	-> извежда броят думи във файл /etc/passwd
wc -c /etc/passwd	-> извежда броят символи (ПРИ ASCII !!) във файл /etc/passwd
Може да комбинираме опции по следния начин:
wc -wc /etc/passwd	-> извежда броят думи и броят символи във файл /etc/passwd

1) 
read	-> приканва потребителят да въведе низ.

Общ вид на командата: 
read str1 str2... strn 	

Пример: 
read input1 input2
Hello Nadq!
#низът Hello се асоциира с променливата input1, а Nadq! се асоциира с променливата input2
echo "$input1 $input2"
#със специалния символ "$" можем да достъпим стойност на променлива. "$" форсира изчисляване. По-надолу има примери.

2)
sleep 5 	-> вкарва ни в 5 секунден интервал на изчакване.

3)
Фонов режим на изпълнение - чрез специален символ &
sleep 5 &	-> ще стартираме изчакването във фонов режим. Така изчакването остава прозрачно за потребителя.

4)
Работа с променливи:
my_var=5
echo $my_var	-> ще изведе на стандартния изход стойността на променливата "my_var"
echo my_var 	-> ще изведе на стандартния изход стринга "my_var"

read enter_your_name
dancho
echo $enter_your_name
my_var=$(grep dancho /etc/passwd)	-> ще присвой на променливата my_var изхода от команден ред grep "dancho" /etc/passwd "$" изисква първо да се изчисли изхода от "grep dancho /etc/passwd".  Пример: ако в /etc/passwd има общо трима потребителя с последователност от символи "dancho" в името си, изхода ще е: echo $my_var dancho:x:...  danchocho:x:...  dadancho:x:...  5) http://www.robelle.com/smugbook/wildcard.html

Wildcards към команда ls
Създаваме десетина файла, с които да работим:
touch a ab bab cba xba axb zz zzb
ls -l a* 	-> ще изведе информация за всички файлове започващи с буква "a", без значение дали има други символи след буквата.
ls -l *a	-> ще изведе информация за всички файлове завършващи с буква "a", без значение дали има други символи преди буквата.
ls -l a		-> ще изведе информация само за файлът "a"
ls -l *a*	-> ще изведе информация за всички файлове съдържащи буквата "a" ls -l a[bcd]	-> ще изведе информация за файлове "ab, ac, ad"
ls -l a[c-z]	-> ще изведе информация за файлове "ac, ad, ae, af,... , az"
ls -l a[A-Z]*	-> ще изведе информация за всички файлове започващи с малка буква "а", последвани от една произволна голяма 
латинска буква, без значение дали има други симвoли след голямата латинска буква.

6)
Всяка команда е асоциирана със стандартен вход, стандартен изход и изход за грешки. Можем да ги манипулираме.
Стандартен изход: ако програмата завърши успешно и има за цел да изведе изход. 
Пример
ls
a ab bab cba xba axb zz zzb	-> стандартен изход.
ls > my_file_01 	-> пренасочваме изхода от команда ls, към файл my_file_01. ">" ако файлът не съществува го създава, ако съществува го занулява. Да се внимава!
ls >> my_file_01	-> пренасочваме изхода от команда ls, към файл my_file_01. ">>" ако файлът не съществува го създава, ако съществува добавя съдържението към края на файла (append)

Изход за грешки: когато програмата завърши с неуспех.
пример:
cp
cp: missing operand... 	-> команда cp изисква минимум два аргумента. Съответно извежда съобщение за грешка.
cp 2> my_file_02	-> пренасочваме изхода за грешки към файл my_file_02
cp 2>> my_file_02	-> пренасочваме изхода за грешки към файл my_file_02
Внимание:
cp > my_file_02		-> Какъв ще е резултатът от този команден ред? Защо?

Стандартен вход:
read whats_your_name
Lora
Горния пример приканва потребителя да въведе вход!
Манипулация на стандартния вход:
echo Lora > my_file_with_names
read whats_your_name < my_file_with_names
echo $whats_your_name
Lora

6.5)
Код на изход на команда
След завършването си на изпълнение (успешно или не) всяка команда връща код на изход.
Кодът на изход можем да видим с изпълнението на следния команден ред:
echo $?
Aко командата е завършила успешно тя връща код на изход 0 и по-голям от 0 в противен случай.
Максималната стойност, която може да върне е 255, тъй като за целта е заделен 1 байт памет.
Пример:
ls
echo $?
0

cp
cp: missing file operand
Try 'cp --help' for more information.
echo $?
1

7)
http://www.robelle.com/smugbook/regexpr.html

Регулярни изрази към команда grep
Особеност при използване на регулярни изрази към команда grep, е че звездата се асоциира със символa пред нея.

*
.

[]
[a-z]
[^]
\<\> - empty string at the beginning and end
escaping - \
| - or

    grep smug files         {search files for lines with 'smug'}
    grep '^smug' files      {'smug' at the start of a line}
    grep 'smug$' files      {'smug' at the end of a line}
    grep '^smug$' files     {lines containing only 'smug'}
    grep '\^s' files        {lines starting with '^s', "\" escapes the ^}
    grep '[Ss]mug' files    {search for 'Smug' or 'smug'}
    grep 'B[oO][bB]' files  {search for BOB, Bob, BOb or BoB }
    grep '^$' files         {search for blank lines}
    grep '[0-9][0-9]' file  {search for pairs of numeric digits}

Нека във файла my_file имаме следните редове:
dan
danc
danch
dancho
dancho123
danchoo
danchooo
danchoooo123
Тогава регулярният израз:
grep "dancho*$" /etc/passwd
ще ни даде следния изход:

danch
dancho
danchoo
danchooo

Логиката, по която работи е следната:
изведи всички редове завършващи на низа "danch" последван от символа "о" срещащ се нула или повече на брой последвателни пъти.

grep "^[a-z]" /etc/passwd	-> ще изведе всички редове започващи с малка латинска буква
grep "[0-9]$" /etc/passwd	-> ще изведе всички редове завършващи на цифра

8) Конвейр
До момента винаги изпълнявахме по една команда и считахме, че резултатът е достатъчен. Но ако желаем да продължим по ефикасен начин обработката на изхода ни, прилагаме конвейр.
Изхода от една команда го подаваме като вход на друга команда
Пример:
Нека имаме файл /etc/passwd със съдържание:
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
saslauth:x:499:76:"Saslauthd user":/var/empty/saslauth:/sbin/nologin

Желаем да изведем само трето поле спрямо разделител ":" на редовете съдържащи низа "ftp" и да пренасочим изхода към файл "my_file_03"
grep "ftp" /etc/passwd | cut -f3 -d ":" > my_file_03


bonus
---
/dev/null
!number
