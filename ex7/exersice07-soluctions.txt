Операционни системи, упражнение 08, решения

1)
Да се състави командна процедура, която получава като параметри на комадния ред, при стартиране, два символни низа - 
потребителско име и име на съществуващ файл, който съдържа информация за текущо стартираните процеси от всички потребители. 
Нека процедурата да прекратява изпълнението на всички процеси, стартирани от потребителя, подаден като входен параметър и записва 
броя на тези процеси във файл с име - името на потребителя.

Приемаме, че съдържанието на файла, подаден като входен параметър, има следната структура:
UID PID STIME COMMAND
root 23787 13:36 /bin/chroot
lora 23791 13:36 /bin/rsync
milena 23792 13:36 /bin/dmidecode
vasilen 23843 13:50 /bin/dd
panayot 23847 13:58 /bin/ls -alhtris
dancho 23848 13:58 /bin/cat
manuela 23849 13:58 /bin/gz
dimitar 23891 14:36 /bin/tar
irina 23892 14:36 /bin/lspci
sendmail 23943 14:50 /bin/date
georgi 23947 14:58 /bin/lvdisplay
liubomir 23948 14:58 /bin/vgdisplay
asen 23949 14:58 /bin/uname -a
и че потребителските имена не съдържат празни символи.

*Ако виждате името си - обяснете стартирана от вас команда. Ще получите +. Може да използвате Интернет.
**Ако не виждате името си - обяснете команда по ваш избор. Ще получите +. Може да използвате Интернет.
***Нямате право да избирате команди на специалните потребители: root, sendmail и dancho.

Решение:
#проверка дали позиционните параметри са точно 2
if [ $# -ne 2 ]
then
        echo "Wrong number of arguments, try with 2! "
        exit 99
fi

#Вариант 1:
#$2 е файлът с информация за стартираните процеси, който сами сме си направили например с изпълняването на следния команден ред: "ps aux > txt.txt"

#От стартираните процеси извличан (grep) тези, които са на потребител подаден като първи позиционен аргумент, след което извличам PID-а на процеса и го убивам.
#Тъй като стартираните процеси може да са повече от 1 итерирам по всички извлечени PID-ове.
for i in $(grep ^$1 "$2" | cut -f2 -d " ")
do
        kill -9 $i
done

#Вариант 2, ако не работехме върху фиктивен файл, а върху реално текущо стартираните процеси:
#Убиваме (спираме, killall) всички процеси (-a) на потребител (-u) подаден като първи позиционен аргуемнт ($1)
killall -a -u $i

2)
Да се състави командна процедура, която получава като параметър на командния ред символен низ - име на процес. 
Ако процес с това име е стартиран в системата, създава директория, чието име е прочетено от стандартния вход, с пълни права за 
собственика, четене и изпълнение за групата му и никакви права за останалите. Копира в нея всички изпълними обикновени файлове 
от началната потребителска директория.

Решение:
#Проверяваме дали има стартиран процес подаден като 1-ви аргумент
#ps aux извежда всички текущо стартирани процеси на системата (сървърчето/компютърчето, на което работим)
#grep $1 извлича всички процеси с това име
# wc -l преброяваме ги
# -ge 1 ако има поне 1 стартиран такъв процес продължаваме по условието на задачата
if [ $(ps aux | grep $1 | wc -l) -ge 1 ]
then
        #Приканваме потребителя да въведе име на директория (стартен вход)
        echo -n "Enter directory name that will be created: "
        read dir_name

        #Създаваме директория с въведеното име
        mkdir $dir_name

        #Задаваме пълни права на собственика на директория (7)
        #Задаваме на групата на файла права за четене (r = 4) + права за достъп до съдържанието на директорията (x = 1) общо 5.
        #Задаваме никакви права за всички останали (0)
        chmod 750 $dir_name

        #Копираме всички изпълними файлове от home директорията ни в ново създадената директория.
        for i in $(ls ~/)
        do
                if [ -f $i & -x $i ]
                then
                        cp $i $dir_name
                fi
        done
fi

3)
Да се състави командна процедура, която получава на комадния си ред, при стартиране произволен брой аргументи.
Нека командната процедура проверява дали подаден входен параметър е директория и ако е - обхожда съдържанието му и за всеки
обикновен файл със зададен собственик съотвестващ на зададения собственик на родителската му директория да променя групата на 
файла да бъде като групата на родителската директория и задава само права за четене на групата.
Ако входния параметър не е директория, нека параметърът бъде пропуснат от последвала обработка.

забележка: 
Ако до момента имате поне една оценка по-висока от 4.5 по ОС, нямате право да обхождате подадените позиционни параметри с 
оператор за цикъл "for"
*попитайте с команда shift

Решение:
#обхождаме позиционните параметри
for i in $*
do
        #проверяваме дали текущия позиционен параметър е директория
        if [ -d $i ]
        then
                #ако е директория обхождаме съдържанието ѝ
                for j in $(ls $i)
                do
                        #проверяваме дали съдържанието има обикновени файлове
                        if [ -f $j ]
                        then
                                #ако има обикновен файл, то:
                                #проверяваме дали собственика на файла (файлът е $j, а собственикът е 3то поле от изхода на команда ls -l за $j) не е същият като този на родителската директория (родителската директория е $i и с ls -ld виждаме нейните права, от които извличаме 3то поле - собственикът ѝ)
                                if [ $(ls -l $j | tr -s " " | cut -f3 -d" ") = $(ls -ld $i | tr -s " " | cut -f3 -d" ") ]
                                then
                                        #ако двете съвпадат, то сменяме групата на файла ($j) да е такава каквато е на родителската директория ($i)
                                        chown .$(ls -ld $i | tr -s " " | cut -f3 -d" ") $j

                                        #също така сменяме правата на групата за достъп до файла.
                                        chmod g=r $j
                                fi
                        fi
                done
        fi
done

4)
Напишете командна процедура, която приканва потребителя да въведе факултетният си номер. 
Докато потребителя не въведе ФН, процедурата продължава да го приканва. 
При коректно въведен ФН да се създаде файл в текущата директория с име стойността на въведения ФН и съдържание отново същата стойност. 
Ако ФН е четно число да се зададат пълни права за достъп върху  новосъздадения файл, в противен случай да се зададат единствено права за четене и писане.

Решение:
while [ true ]
do
        #приканваме потребителят да въведе факултетният си номер
        echo -n "Въведете факултетният си номер: "
        read fac_num

        #ако факултетният номер е число правим нещо си, иначе пак бива приканен
        if [ $fac_num -eq $fac_num ] 2> /dev/null
        then
                #създаваме файл си име $fac_num и съдържание $fac_num
                echo $fac_num > ./$fac_num
                #ако $fac_num е четно, задаваме пълни права, иначе само за писане и четене
                if [ $(expr $fac_num % 2) -eq 0 ]
                then
                        chmod 777 $fac_num
                else
                        chmod 666 $fac_num
                fi
                break
        fi
done

5)
Да се състави командна процедура, която получава като параметър на командния си ред, при стартиране, символен низ - потребителско име. 
Нека процедурата да прекратява изпълнението на всички cat процеси, стартирани от потребителя, подаден като входен параметър и записва броя на тези процеси във файл с име - името на потребителя.

примерно решение
ps -u $1 | grep "cat" | wc -l > $1.txt
killall -9 cat -u $1

6)
Да се състави командна процедура, която обхожда файловете в HOME директорията на текущия потребител. 
За всеки файл в директорията, който има друг собственик, процедурата сменя собственика и групата на файла с текущия 
потребител и неговата група.

Решение:
#обхождане на всички файлове в текущата директория
for i in $(ls ~/)
do
        #ако сме текущо на обикновен файл със собственик различен от мен..
        if [ -f $i -a $(ls -l $i | tr -s " "| cut -f3 -d" ") != $(whoami) ]
        then
                #сменяме собственика и групата на файла да бъдат мен.
                chown $(whoami).$(whoami) $i
        fi
done
