Права на достъп:
В модерните файлови системи всеки файл има права на достъп.
*В Linux всичко е файл, дори клавиатурата и мишката.

Правата на достъп до файл може да видим с команда "ls -l"
-rwxr-x--- 1 jbabukov teachers  114 Nov  2 12:58 loveTriangle.sh

Правата за достъп до файла са описани в първо поле, спрямо разделител " " или иначе казано "-rwxr-xr-x".
Първият символ '-' ни носи информация за типа на самия файл.
'-' означава, че файлът е обикновен.
'd' означава, че файлът е директория.
'l' означава, че файлът е символна връзка.
'c' означава, че файлът е character device. Пример за такъв файл е файлът асоцииран с клавиатурата. (ls -l /dev/)
'b' означава, че файлът е block device.

Следват три тройки права. rwx rwx rwx. Ако някое от правата не е налично се означава с '-'

Първата тройка права указват какво е позволено за собственикът на файла. 
В случая първата тройка права е 'rwx' и дава права за четене(Read), права за писане(Write) и права за изпълненение на файла (eXecute) на собственика на файла.

Следващата тройка права са за групата, към която файлът принадлежи.
В случая те са 'r-x', което означава, че групата може да прочете съдържанието на файла, както и да го изпълни, но не и да модифицира съдържанието на файла.

Последната тройка права са за всички останали.
В случая '---' не позволява на никого освен собственика и групата на файла да правят каквото и да било с този файл.

*Aко правата бяха -rwx------ означава, че само аз мога да си играя с файла.

Модифициране на права за достъп до файл:
chmod u+r -> добавя права за четене на собственика (user)
chmod g-wx -> премахва права за писане и изпълнение на групата (group)
chmod o-rwx -> премахва всички права на всички останали (others)
chmod -x -> премахва права за изпълнение на файла от всички (собс, група, всички останали)
chmod +rx -> добавя права за четене и изпълнение на файл към всички (собс, група, всички останали)
chmod u=r -> залага единствено права за четене на собственик. На групата и всички останали не се променят.
chmod u= -> занулява правата за достъп до файла на собственика.
chmod = -> занулява правата за достъп до файла до абсолютно всички.

Алтернативен начин за работа с правата на файлове:

Всяка тройка от права е представена в бинарен вид:
rwx = 2^2, 2^1, 2^0, или иначе казано rwx -> 421
За задаване на пълни права до собственика и никакви до всички останали става така:
chmod 700 (read+write+execute за собственика и 0 за групата и останалите)

Залагане на sticky bit:
chmod 1752 -> само собственикът на файла може да изтрие файла, независимо от w правата. Пример за такава директория е /tmp

SUID
chmod 2710 -> файлът се изпълнява с правата на собственикът на файлът, а не с тези на изпълнителят. Пример за такава команда е ping. ls -l /bin/ .

GUID 
chmod 4763 -> файловете, които биват създадени в директория с вдигнат GUID бит наследяват групата на собстветника на директорията.

Пример с права:
Аз съм си разрешил на мен и на групата към която съм (преподавателите) да ми виждат съдържанието на директорииката, а на всички останали (вас) съм забранил.
*Ако някой ме хакне ще се сдобие с решение на домашното - давайте.

Да създадем 1 файл и 1 директория:
touch f1
mkdir dir1
[manuela@georgi lora]$ls -l f1
-rw-r--r-- 1 jbabukov teachers 0 Oct 19 11:27 f1

[manuela@georgi lora]$ls -ld dir1
drwxr-xr-x 3 jbabukov teachers 4096 Nov 11 16:55 dir1

По подразбиране по security причини ново създадените файлове нямат пълни права. Например ако си създадем директория попринцип не бихме искали другите да могат да създават и трият файлове от нея. Затова няма права w.

Това става чрез umask
[manuela@georgi lora]$umask
0022
umask е като шапка. Ако правата на файла са 777, тя слага -0 на 1вите права, -2 на вторите и -2 на третите. Крайният резултат е: 755 или rwxr-xr-x, което виждаме за директория.

Правата x за директория определят дали може да влезем в папката, а 'r' дали може да ѝ прочетем съдържанието.
За файл правото x определя дали файлът може да бъде изпълнен. Тъй като е опасно всеки да може да изпълни файл по подразбиране на ново създадените файлове им се слага umask 133, вместо 022, което премахва x правото.

Още един пример с права на файл:
Когато споделяте нещо с dropbox, другият може да го види само ако му предоставим линка.

Това става като имаме директория с права --x--x--x. Всеки може да достъпи съдържанието на директорията, но само ако знаете изрично как се казва, тъй като нямате права за изследване на съдържанието ѝ.

Смяна на собственика и група:
chown jbabukov f1 -> сменя само собственика
chgrp jbabukov f1 -> сменя само групата
chown jbabukov:jbabukov f1 -> сменя собственик и група
chown :jbabukov f1 -> сменя само група
chown jbabukov.jbabukov f1 -> аналогично на :
chown .jbabukov f1 -> аналогично на :

Процеси:
ps -> дава инфо за стартираните процеси от потребителя (ама много оскъдно)
*Процес -> програмен код в хода си на изпълнение. 

Всеки процес има PID (process ID)
За повече инфо относно процесите:
ps aux (a -> all, u -> user, x -> произволен потребител) т.е. дава инфо за всички процеси на всички потребители.

За конкретен потребител:
ps -a -u jbabukov

ps aux | wc -l 
Това са всички текущо стартирани процеси. само 15тина са от нас, другите са системни. Те са нужни за да имаме работна среда.

Кое е хардуерната компоненета, която изпълнява тези процеси? 

1 процесор, може да изпълни 1 процес даден момент, но  го прави толкова бързо, че ние си мислим че вървят паралелно.

ps -a -u jbabukov ft 

Така може да видим йерархията на стартираните процеси.
Стартирал съм sshd сесия (това при аутентикирането)
След това се е стартирал bash за мен. После съм стартирал процеса ps.

Родителя на процеса се грижи да изчака детето да приключи изпълнението си и чак след това се връща в нормален режим на работа.
Пример: sleep 5 -> bash (родителят) изчаква процеса да завърши и чак тогава пак сме ние.

За всеки стартиран процес се заделя памет (хардуерен ресурс), какво се случва ако бащата не изчака процеса и той си увисне във въздуха?
Осиновява се от init процеса - 1вият процес.

Убиване на процес:
kill -9 PID  -> убива единичен процес
killall -9 processName  -> убива всички инстанции на процес (например няколко стартирани и зависнали firefox-a)

Работа с процеси стартирани във фонов режим:
sleep 10000 &
ps aux | grep sleep
процеса си стои..
jobs 	-> извежда всички стартирани процеси във фонов режим от мен.
fg	-> променя режима на стартирания процес от фонов (background) в явен (fg = foreground)
ctrl + c спираме текущия процес.

Пример за приложение на тези команди
vi 123
shift + z + z (изпращаме vi процеса във фонов режим)
Разглеждаме си нещо
fg (връщаме vi процеса да е текущ)
Работим си върху скрипта.

