Операционни системи, упражнение 12

Cистемни примитиви за работа с процеси и работа с файлове под C

Функции, които ще трябва да знаете и ползвате:
open()
read()
write()
close()
fork() 
wait()
execl();
execlp();
exit();

Задача 1:
1. Да се напише програма на С, която получава като параметър команда (без параметри) и при успешното й изпълнение 
извежда на стандартния изход името на командата.

Решение:
//1. Да се напише програма на С, която получава като параметър команда (без параметри) и при успешното й изпълнение извежда на стандартния изход името на командата.
#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

main(int argc, char* argv[]){
        int status; //променлива ползваща се от wait() и съдържаща кода на завършване на процеса дете.
        //fork връща 0 при детето и > 0 при бащата. По този начин различаваме кой процес, кой е.

        if( fork() > 0 ){
        //тяло на бащата > 0
                wait(&status); //инструктираме процеса баща да изчака завършването на процеса син.
                //долните два реда ще се изпълнят чак след като сина завърши.
                printf("Name of executed command is: %s\n", argv[1]);
                exit(0);
        }
        else{
                //тяло на сина = 0
                //чрез execlp изпълняваме процес, с цената на смяна на образа на този, който го
 изпълнява.
                if ( execlp(argv[1], argv[1], 0) == -1 ){
                        exit(99);
                }
                else{
                        //кодът след смяната на образа на процеса никога няма да бъде изпълнен.
                        printf("Will this line ever be printed? Why?\n");
                        exit(0);
                }
        }
}

Задача 2:
Да се напише програма на С, която получава като параметри три команди (без параметри), изпълнява ги последователно,
като изчаква края на всяка и извежда на стандартния изход номера на завършилия процес, както и неговия код на завършване.

Решение:
//Да се напише програма на С, която получава като параметри три команди (без параметри), изпълнява ги последователно, като изчаква края на всяка и извежда на стандартния изход номера на завършилия процес, както и неговия код на завършване.
#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

/*
За по-добра четимост на кода съм премахнал коментарите от миналата задача, тъй като са идентични.
*/

main(int argc, char* argv[]){
        int status;     // съдържа код на завършване на процес дете.
        int pid_of_child;       // в случаят, когато fork връща стойност > 0, тази стойност е pid-а на процеса син. При "форкване" ще пазя тази стойност в променлива с интуитивно име "pid_of_child"
        int i; //ще направя for цикъл, който да ми обходи входните параметри и да ги изпълни последователно.

        for (i=1; i<4; i++){
                //тяло на бащата > 0
                //тук се случва врътката с пазенето на pid-a на процеса син в променлива
                if( ( pid_of_child = fork() ) > 0 ){
                        wait(&status);

                        //долните три реда ще се изпълнят чак след като сина завърши.
                        printf("Pid of first child is: %d, %d\n", pid_of_child, getpid() );
                        printf("Exit code of child with pid %d is: %d\n", pid_of_child, status);
                        //забележете, ако не сложа в коментар exit, ще се изпълни само веднъж!
                        //Това е, защото процеса баща е самата програма, на която разглеждаме кода в момента.
                        //exit(0);
                }
                //тяло на сина = 0
                else{
                        if ( execlp(argv[i], argv[i], 0) == -1 ){
                                exit(99);
                        }
                        else{
                                printf("Will this line ever be printed? Why?\n");
                                exit(0);
                        }
                }
        }
}


3. Да се напише програма на С, която получава като параметър име на файл. Създава процес син, който записва 
стринга "Hello Tux!" във файла (ако не съществува, го създава, в противен случай го занулява), след което процеса родител 
прочита записаното във файла съдържание и го извежда на стандартния изход, добавяйки между символите, празен символ.

Забележка: Ако някой си мисли, че Tux е нещо за хапване, моля да отвори връзката, предоставена на долния ред.
http://en.wikipedia.org/wiki/Tux
http://fc01.deviantart.net/fs13/f/2007/099/7/7/Kill_Bill_by_lahandi.png

Решение:
//Да се напише програма на С, която получава като параметър име на файл. Създава процес син, който записва стринга "Hello Tux!" във файла (ако не съществува, го създава, в противен случай го занулява), след което процеса родител прочита записаното във файла съдържание и го извежда на стандартния изход, добавяйки между символите, празен символ.

#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

/*
За по-добра четимост на кода съм премахнал коментарите от миналата задача, тъй като са идентични.
*/
main(int argc, char* argv[]){
        int status;     // съдържа код на завършване на процес дете.
        int fd1;
        char c;

        //тяло на бащата > 0
        if( fork() > 0 ){
                wait(&status);
                if( ( fd1 = open(argv[1], O_RDONLY, 0600 ) ) == -1 ){
                        write(2, "Something went wrong!\n", 22);
                        exit(99);
                }
                else{
                        while ( read(fd1, &c, 1) == 1 ){
                                write(1, &c, 1);
                                if(c == '\n') continue;
                                c=' ';
                                write(1, &c, 1);
                        }
                }
                exit(0);
        }
        //тяло на сина = 0
        else{
                if( ( fd1 = open(argv[1], O_WRONLY|O_CREAT|O_TRUNC, 0600 ) ) == -1 ){
                        write(2, "Something went wrong!\n", 22);
                        exit(99);
                }
                else{
                        write(fd1, "Hello Tux!\n", 11);
                        close(fd1);
                }
        }
}
