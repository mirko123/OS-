Разписани упражнения по Операционни системи за специалност Информатика от Йордан Бабуков.

Операционни системи, упражнение 11

Cистемни примитиви за работа с процеси под C

Кратък увод в тема: какво са процесите?
Днешните операционни системи такива каквито ги познаваме са многозадачни.
Това означава, че успяват да се справят с изпълнението на много процеси "наведнъж", например докато работим с 
мишката може да слушаме музика заедно с това да гледаме видео клип, заедно с това на заден фон (background) да сме 
стартирали програма за съпоставяне на нуклеотидни прoчити от генома на пшеницата и още куп други странни неща. 
Всяко едно от изброените събития е свързано с даден процес изпълняващ се на нашия компютър.
Тези процеси се изпълняват от хардуерна компонента, наречена.. процесор.

Как всъщност се обработват "наведнъж" стартираните процеси?
В най-простият случай процесора е един, с една нишка. т.е. няма как да обработи повече от един процес в даден 
момент. Но... той постига заблудата паралелизъм, на която ние се наслаждаваме, като обработва процесите 
последователно един по един, но ги редува толкова бързо че ние не разбираме, за настъпването на смяната между 
различните процеси мишка-музика-клип-съпоставяне-мишка-музика-клип-съпоставяне и тн.

В общия случай имаме около 60-100 процеса, които трябва бъдат изпълнявани на този редуващ се принцип.

Как се определя кой процес, колко време да бъде изпълняван?
Процесите се изпълняват от процесора на конкурентен принцип. Всеки един от тях се бори за процесорно време.
Тъй като при тази борба, някой процес може да стане прекалено алчен за процесорно време и да заеме целия ресурс,
съществува механизъм в ядрото нареден scheduler, който ни идва на помощ.
Този scheduler указва на всеки процес, колко процесорно време да му бъде заделено(например два процесорни такта). 
Това става чрез определяне на nice levels за процесите.

Пример: ако музикалния player е с най-висок приоритет, то при мърдане на мишката, тя ще насича, тъй като процеса
свързан с нея, ще трябва да изчака да му дойде реда за изпълнение от процесора.
Обратното: ако мишката е с най-висок приоритет, при събитие свързано с нея, музиката ни ще започва да прекъсва. 

Затова гоним златната среда. Оптималният компромисен вариант, така че всичко да върви без ние да усещаме прекъсване.
Една от меките на линукс се крие точно в този scheduler и как той разпределя процесорното време. Може и ние
самите да си играем (внимателно) с nice level-ите на процесите.

1)
int execl(const char *path, const char *arg, ..., 0);
първият аргумент е пълно име на бинарен файл (команда), която искаме да изпълним
вторият аргумент е името на самата команда
Следват N на брой аргументи - опции към командата, която искаме да изпълним
Последният аргумент е 0, указва край на въвеждане на аргументи.

Пример: 
искам да изпълня команда ls с опция -l
execl("/bin/ls", "ls", "-l", 0);

Особености (които трябва да знам):
При изпълнение на системния примитив execl се сменя образа на процеса, който я е изпълнил.
т.е. изпълни ли се execl -> сменя се текущата програма с програмата ls и връщане назад, няма.
Oще примери - най-долу директно в задача.

Особености (които не е нужно да знаем):
Първият аргумент на функцията е бинарният файл, който искаме да изпълним.
Вторият аргумент е какво ще бъде името на стартирания процес, което може да видим с команда ps.

2)
int execlp(const char *file, const char *arg, ..., 0);
Аналогично на execl, но първият аргумент е собствено име на командата ( не пълният път до нея )

Пример: 
искам да изпълня команда dd с две опции if=/dev/uradom и of=/etc/ (Внимание: не я пробвайте!)
execlp("dd", "dd", "if=/dev/uradom", "of=/etc/", 0);

3)
exit(5);
Процес прекратява собственото си изпълнение и връща код на завършване.

4)
fork();
Създава нов процес(дете)
Ново- създаденият процес е почти идентичен на бащиния (този, който го е създал).
Защо почти? ами различават се например по PID (process ID, всеки процес има уникален PID)
Тъй като са почти идентични процесите, трябва някак да ги различаваме.
Различаваме ги по това какво връща fork().
fork() връща 0 при детето и > 0 при бащата.

5)
wait(&status);
Тъй като процесите се изпълняват на конкурентен принцип, бащата може да завърши изпълнението си преди детето.
Но ако искаме изхода от детето да го ползваме в бащата, то трябва да укажем на бащата да изчака детето да завърши.
Това става чрез системен примитив wait().
Той следи за промяна на статуса на детето:
Например настъпване на терминиране на процеса или на пауза или на събуждане от пауза.

6)
get_pid(); 	-> връща PID на процеса, който изпълнява командата.
get_ppid();	-> връща PID на бащата на процеса, който изпълнява командата.

Задача 1:
Да се напише програма на C, която изпълнява команда date.
]$ vi task1.c
#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

main (){
	//Системните примитиви връщат -1 при грешка и > -1 при успех.
        if ( execl("/bin/date", "date", 0) == -1 ){
                exit(99);
        }
        else{
		//След изпълнение на execl настъпва смяна на образа на текущия процес (самата програма, която пишем сега)
		//и в последствие ще стартираме с образа на команда date и долният ред няма да бъде изпълнен никога!
                printf("If Nenkov only knew that I know that Hristova will know what Ivanov knows now..\n");
                exit(0);
        }
}

Остава да си компилираме творението:
cc task1.c -o task1
сега го стартираме и се наслаждаваме на резултатите:
./task1

Задача 2:
Да се напише програма на C, която изпълнява команда ls с точно един аргумент

#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

main(int argc, char* argv[]){
        if (argc == 2){
//debugging
//              printf("%s", argv[1]);
                if ( execlp("/bin/ls", "ls", argv[1], 0) == -1 ){
                        exit(99);
                }
                else{
                        printf("Will this line ever be printed? Why?\n");
                        exit(0);
                }
        }
        else{
                printf("Number of args is %d, enter exactly one.", argc);
                exit(0);
        }
}

Задача 3:
Да се напише програма на C, която поставя Мануела в режим на спане за 60 секунди.

#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

main(int argc, char* argv[]){
        if (argc == 2){
//debugging
//              printf("%s", argv[1]);
                if ( execlp("/bin/sleep", "manuela", "60", 0) == -1 ){
                        exit(99);
                }
                else{
                        printf("Will this line ever be printed? Why?\n");
                        exit(0);
                }
        }
        else{
                printf("Number of args is %d, enter exactly one.", argc);
                exit(0);
        }
}

Задача 4:
Да се напише програма на C, която създава процес дете и демонстрира принцина на конкурентност при процесите.

#include <stdio.h> //printf
#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

main(int argc, char* argv[]) {
        int i,j;

        if( fork() > 0 ){
		//father body
                for( i=0; i<1000000; i++) write(1,"i'm your father\n", 16);
        }else{
		//child body
                for( i=0; i<1000000; i++) write(1,"i'm your son\n", 13);
        }
}

Задача 5:
Да се напише програма на C, която е аналогична на горния пример, но принуждава бащата да изчака сина си да завърши, преди да започне собственото си изпълнение.

#include <unistd.h> //execl, execlp
#include <sys/types.h> // fork, getpid, getppid
#include <sys/wait.h> // wait
#include <stdlib.h> // exit

main(int argc, char* argv[]) {
        int i,j;
	int status;

        if( fork() > 0 ){
		//father body
		wait(&status);
                for( i=0; i<1000000; i++) write(1,"i'm your father\n", 16);
        }else{
		//child body
                for( i=0; i<1000000; i++) write(1,"i'm your son\n", 13);
        }
}
